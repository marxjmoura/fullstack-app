<!doctype html><html lang="en"><head><meta charset="utf-8"><meta name="theme-color" content="#ffffff"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="author" content="Marx J. Moura"><meta name="description" content="This is a step-by-step guide on how to configure Nginx on Ubuntu Server to run a single or multiple ASP.NET Core APIs on one domain (no subdomain)."><meta property="og:title" content="Host ASP.NET Core on Linux with Nginx"><meta property="og:image" content="https://fullstack.app/posts/2019/08/18/cover.png"><meta property="og:description" content="This is a step-by-step guide on how to configure Nginx on Ubuntu Server to run a single or multiple ASP.NET Core APIs on one domain (no subdomain)."><meta property="og:url" content="https://fullstack.app/posts/2019/08/18/host-aspnet-core-on-linux-with-nginx.html"><title>Host ASP.NET Core on Linux with Nginx</title><link rel="icon" href="/favicon.ico"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Serif+Pro:400,700&display=swap"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css" integrity="sha256-UzFD2WYH2U1dQpKDjjZK72VtPeWP50NoJjd26rnAdUI=" crossorigin="anonymous"><link rel="stylesheet" href="/blog.min.css"></head><body><div class="container"><div class="text-right mb-3"><div class="dropdown"><button type="button" class="btn btn-sm dropdown-toggle" data-toggle="dropdown">EN</button><div class="dropdown-menu"><a href="/br/posts/2019/08/18/hospedar-aspnet-core-no-linux-com-nginx.html" class="dropdown-item">BR</a> <a href="/" class="dropdown-item">EN</a></div></div></div><div class="header"><h1><a href="/">Full-Stack Applications</a></h1><div class="techs"><svg><use href="/images/techs.svg#netcore"/></svg> <svg><use href="/images/techs.svg#vue"/></svg> <svg><use href="/images/techs.svg#postgresql"/></svg> <svg><use href="/images/techs.svg#rabbitmq"/></svg> <svg><use href="/images/techs.svg#nginx"/></svg> <svg><use href="/images/techs.svg#ubuntu"/></svg> <svg><use href="/images/techs.svg#aws"/></svg> <svg><use href="/images/techs.svg#github"/></svg> <svg><use href="/images/techs.svg#circleci"/></svg></div></div><form method="get" action="https://www.google.com/search" class="google-search"><input type="hidden" name="sitesearch" value="fullstack.app"> <input type="text" name="q" class="form-control form-control-sm" placeholder="Google"></form><small>18 August 2019</small><h1>Host ASP.NET Core on Linux with Nginx</h1><figure><img src="/posts/2019/08/18/cover.svg" alt=".NET Core + Linux + Nginx"></figure><p>This is a step-by-step guide on how to configure Nginx on Ubuntu Server to run a single or multiple ASP.NET Core APIs on one domain (no subdomain).</p><p>This post is quite extensive so let's break into steps to achieve this:</p><ol><li><a href="#install-nginx">Install Nginx</a></li><li><a href="#configure-firewall">Configure firewall</a></li><li><a href="#configure-nginx">Configure Nginx</a></li><li><a href="#create-the-server-block-for-the-domain">Create a server block for the domain</a></li><li><a href="#configure-aspnet-core-api">Configure ASP.NET Core API</a><ol><li><a href="#configure-aspnet-core-api-as-a-service">Configure the ASP.NET Core API as a service</a></li><li><a href="#configure-single-aspnet-core-api-on-the-domain">Configure a single ASP.NET Core API on the domain</a></li><li><a href="#configure-multiple-aspnet-core-api-on-one-domain">Configure multiple ASP.NET Core APIs on one domain</a></li></ol></li></ol><p></p><h2 id="install-nginx">1. Install Nginx <a href="#install-nginx"></a></h2><p>First of all we need Nginx installed on the server. We can use <code>apt-get</code> to install.</p><p><pre><code>sudo apt-get install nginx</code></pre></p><p>After the installation the web server should already be up and running. To check the status of the Nginx run the following command:</p><p><pre><code>sudo systemctl status nginx</code></pre></p><h2 id="configure-firewall">2. Configure firewall <a href="#configure-firewall"></a></h2><p>After install Nginx you may need to open HTTP or HTTPS ports in the firewall. If you are using Amazon EC2 (like me) just use the AWS Management Console to do this and you are ready to go to the <a href="#configure-nginx">next topic</a>.</p><p>Let's list the application configurations that <code>ufw</code> knows how to work with:</p><p><pre><code>sudo ufw app list</code></pre></p><p>There are three profiles available for Nginx to open the ports 80 (HTTP) and port 443 (HTTPS):</p><ul><li><b>Nginx Full:</b> This profile opens both port 80 and port 443.</li><li><b>Nginx HTTP:</b> This profile opens only port 80.</li><li><b>Nginx HTTPS:</b> This profile opens only port 443.</li></ul><p></p><p>Lets run the following command to enable the <b>Nginx Full</b> profile.</p><p><pre><code>sudo ufw allow 'Nginx Full'</code></pre></p><p>Now let's run the following command to verify the change:</p><p><pre><code>sudo ufw status</code></pre></p><h2 id="configure-nginx">3. Configure Nginx <a href="#configure-nginx"></a></h2><p>The following configuration is what I'm using and should be enough to get started. In case you are interesting in details, the <a href="https://nginx.org/en/docs/">Nginx documentation</a> is a good place for reference and also <a href="https://devdocs.io/nginx/">devdocs.io/nginx</a>.</p><p>Create the <code>/etc/nginx/proxy.config</code> configuration file with the content:</p><p><pre><code>proxy_buffer_size 128k;
proxy_buffers 4 256k;
proxy_busy_buffers_size 256k;
large_client_header_buffers 4 16k;</code></pre></p><p>Modify the file <code>/etc/nginx/nginx.config</code> and replace the content with the following:</p><p><pre><code>user www-data;
worker_processes auto;
pid /run/nginx.pid;

include /etc/nginx/modules-enabled/*.config;

events {
  worker_connections 1024;
}

http {
  sendfile on;
  tcp_nopush on;
  tcp_nodelay on;
  types_hash_max_size 2048;
  keepalive_timeout 30;
  server_tokens off;

  include /etc/nginx/mime.types;
  include /etc/nginx/conf.d/*.config;
  include /etc/nginx/sites-enabled/*;
  include /etc/nginx/proxy.config;

  default_type application/octet-stream;

  log_format custom &#x27;$remote_addr - $remote_user [$time_local] &#x27;
                    &#x27;&quot;$request&quot; $status $body_bytes_sent &#x27;
                    &#x27;&quot;$http_referer&quot; &quot;$http_user_agent&quot; &#x27;
                    &#x27;&quot;$http_x_forwarded_for&quot; $request_id &#x27;;

  access_log /var/log/nginx/access.log custom;
  error_log  /var/log/nginx/error.log;
}
</code></pre></p><p>Edit the default server block to handle unmatched <code>server_name</code> by returning the status code of 444 (connection closed without response). Modify the default Nginx server block <code>/etc/nginx/sites-available/default</code> and replace the content with the following:</p><p><pre><code>server {
  listen 80 default_server;
  listen [::]:80 default_server;

  return 444;
}</code></pre></p><p>Test the Nginx configuration for correct syntax:</p><p><pre><code>sudo nginx -t</code></pre></p><p>If there are no errors, restart Nginx.</p><p><pre><code>sudo systemctl restart nginx</code></pre></p><h2 id="create-the-server-block-for-the-domain">4. Create a server block for the domain <a href="#create-the-server-block-for-the-domain"></a></h2><p>First let's create a folder to the domain (e.g. example.com) within directory <code>/var/www</code> using the <code>-p</code> flag to create any necessary parent directories:</p><p><pre><code>sudo mkdir -p /var/www/example.com</code></pre></p><p>Next, to avoid any permission issues, make the Nginx user <code>www-data</code> owner of the directory that we just created:</p><p><pre><code>sudo chown -R www-data: /var/www/example.com</code></pre></p><p>Allow the owner and groups to write to the directory:</p><p><pre><code>sudo chmod -R 775 /var/www/example.com</code></pre></p><p>Add another user to the <code>www-data</code> group if you need to (e.g. ubuntu user of the Amazon EC2):</p><p><pre><code>sudo usermod -a -G www-data ubuntu</code></pre></p><p>Now let's create the server block (a configuration file) <code>/etc/nginx/sites-available/example.com</code> with the following content:</p><p><pre><code>server {
  listen 80;
  listen [::]:80;

  server_name example.com *.example.com;

  location / {
    return 200 &quot;OK&quot;;
  }
}</code></pre></p><p>To enable the new server block it is needed to create a symbolic link from the file in <code>sites-available</code> directory to the <code>sites-enabled</code> directory, which is read by Nginx during startup:</p><p><pre><code>sudo ln -sfn /etc/nginx/sites-available/example.com /etc/nginx/sites-enabled/</code></pre></p><p>Then test the configuration syntax and restart Nginx:</p><p><pre><code>sudo nginx -t</code></pre><pre><code>sudo systemctl restart nginx</code></pre></p><p>Now you should get the text "OK" when accessing http://example.com in your browser.</p><h2 id="configure-aspnet-core-api">5. Configure ASP.NET Core API <a href="#configure-aspnet-core-api"></a></h2><p>Basically we need to configure the ASP.NET Core API as a service and configure the Nginx as a reverse proxy. The <a href="https://docs.microsoft.com/en-us/aspnet/core/host-and-deploy/linux-nginx">Microsoft documentation</a> help me a lot.</p><p>During this process the following configuration files will be created or edited:</p><p></p><ul><code>/etc/systemd/system/my-example-api.service:</code> Service unit configuration file for the ASP.NET Core API.<li><code>/etc/nginx/proxy.config:</code> Proxy configuration file.</li><li><code>/etc/nginx/nginx.config:</code> Nginx configuration file.</li><li><code>/etc/nginx/sites-available/default:</code> Default server block.</li><li><code>/etc/nginx/sites-available/example.com:</code> Domain server block.</li></ul><p></p><h3 id="configure-aspnet-core-api-as-a-service">5.1. Configure the ASP.NET Core API as a service</h3><p>Nginx isn't set up to manage the Kestrel process. Therefore, <code>systemd</code> can be used to create a service file to command (start, stop or restart) and monitor the API.</p><p>Create the service unit configuration file:</p><p><pre><code>sudo vim /etc/systemd/system/my-example-api.service</code></pre></p><p>The following is an example service configuration file for the <i>My Example API</i> (if necessary, change to suit your use case):</p><p><pre><code>[Unit]
Description&#x3D;My Example API

[Service]
WorkingDirectory&#x3D;/var/www/example-api/current
ExecStart&#x3D;/usr/bin/dotnet /var/www/example-api/current/Api.dll
Restart&#x3D;always
RestartSec&#x3D;10
KillSignal&#x3D;SIGINT
SyslogIdentifier&#x3D;my-example-api
User&#x3D;www-data
Environment&#x3D;ASPNETCORE_ENVIRONMENT&#x3D;Production
Environment&#x3D;ASPNETCORE_URLS&#x3D;http://localhost:5000
Environment&#x3D;DOTNET_PRINT_TELEMETRY_MESSAGE&#x3D;false
EnvironmentFile&#x3D;/etc/my.config

[Install]
WantedBy&#x3D;multi-user.target</code></pre></p><p>Start the service and verify that it's running.</p><p><pre><code>sudo systemctl start my-example-api.service</code></pre><pre><code>sudo systemctl status my-example-api.service</code></pre></p><p>Once the API that is running on Kestrel is managed by <code>systemd</code>, all events and processes are logged to the <i>journal</i> (a <code>systemd</code> component). To view the <code>my-example-api.service</code> records, use the following command:</p><p><pre><code>sudo journalctl -fu my-example-api.service</code></pre></p><p>For filtering by time to reduce the amount of records returned:</p><p><pre><code>sudo journalctl -fu my-example-api.service --since "2019-01-01" --until "2019-01-20 06:00"</code></pre></p><h3 id="configure-single-aspnet-core-api-on-the-domain">5.2. Configure a single ASP.NET Core API on the domain</h3><p>It is needed to configure Nginx as a reverse proxy to forward requests made to http://example.com on to the ASP.NET Core API running on Kestrel at http://localhost:5000. Modify the server block <code>/etc/nginx/sites-available/example.com</code> and replace the content with the following:</p><p><pre><code>server {
  listen 80;
  listen [::]:80;

  server_name example.com *.example.com;

  location / {
    proxy_pass http://localhost:5000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection keep-alive;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_cache_bypass $http_upgrade;
    fastcgi_buffers 16 16k;
    fastcgi_buffer_size 32k;
  }
}</code></pre></p><p>Then test the configuration syntax and restart Nginx:</p><p><pre><code>sudo nginx -t</code></pre><pre><code>sudo systemctl restart nginx</code></pre></p><p>The API will be available at http://example.com.</p><h3 id="configure-multiple-aspnet-core-api-on-one-domain">5.3. Configure multiple ASP.NET Core APIs on one domain</h3><p>We will configure Nginx as a reverse proxy to forward requests to multiple ASP.NET Core APIs by using the <code>rewrite</code> directive. Modify <code>/etc/nginx/sites-available/example.com</code> and replace the content with the following:</p><p><pre><code>server {
  listen 80;
  listen [::]:80;

  server_name example.com *.example.com;

  location /myapi1 {
    rewrite /myapi1/?(.*) /$1 break;
    proxy_pass http://localhost:5000;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection keep-alive;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_cache_bypass $http_upgrade;
    fastcgi_buffers 16 16k;
    fastcgi_buffer_size 32k;
  }

  location /myapi2 {
    rewrite /myapi2/?(.*) /$1 break;
    proxy_pass http://localhost:5010;
    proxy_http_version 1.1;
    proxy_set_header Upgrade $http_upgrade;
    proxy_set_header Connection keep-alive;
    proxy_set_header Host $host;
    proxy_set_header X-Forwarded-For $proxy_add_x_forwarded_for;
    proxy_set_header X-Forwarded-Proto $scheme;
    proxy_cache_bypass $http_upgrade;
    fastcgi_buffers 16 16k;
    fastcgi_buffer_size 32k;
  }
}</code></pre></p><p>You will need to have one service configuration file for each API to run both APIs as a service. Just repeat <a href="#configure-aspnet-core-api-as-a-service">the step already described in this post</a> paying attention to the paths and port used.</p><p>Then test the configuration syntax and restart Nginx:</p><p><pre><code>sudo nginx -t</code></pre><pre><code>sudo systemctl restart nginx</code></pre></p><p>Now both APIs <code>myapi1</code> and <code>myapi2</code> will be available on the same server at http://example.com/myapi1 and http://example.com/myapi2 respectively.</p><div class="author"><img src="/images/marxjmoura.jpg" alt="marxjmoura"><div><p class="mb-3">I'm Marx J. Moura. In this blog I write about microservice architecture and web application development.</p><p><a href="https://github.com/marxjmoura/" class="p-1"><i class="fab fa-lg fa-github"></i> </a><a href="https://www.linkedin.com/in/marxjmoura/" class="p-1"><i class="fab fa-lg fa-linkedin"></i></a></p></div></div><div id="disqus_thread"></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/js/all.min.js" integrity="sha256-xzrHBImM2jn9oDLORlHS1/0ekn1VyypEkV1ALvUx8lU=" crossorigin="anonymous"></script><script src="/blog.min.js"></script><script>var disqus_config = function () {
      this.page.url = 'https://fullstack.app/posts/2019/08/18/host-aspnet-core-on-linux-with-nginx.html';
      this.page.identifier = '2019/08/18/host-aspnet-core-on-linux-with-nginx';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://fullstack-app.disqus.com/embed.js';
      s.setAttribute('data-timestamp', + new Date());
      (d.head || d.body).appendChild(s);
    })();</script></body></html>