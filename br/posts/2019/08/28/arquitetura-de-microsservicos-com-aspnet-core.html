<!doctype html><html lang="pt"><head><meta charset="utf-8"><meta name="theme-color" content="#ffffff"><meta name="viewport" content="width=device-width,initial-scale=1,shrink-to-fit=no"><meta name="author" content="Marx J. Moura"><meta name="description" content="Para implementar o padrão de arquitetura de microsserviços, nós construímos uma coleção de APIs com responsabilidades específicas que trabalham em conjunto e se comunicam através de eventos. Vamos ver como podemos fazer isso."><meta property="og:title" content="Arquitetura de microsserviços com ASP.NET Core"><meta property="og:image" content="https://fullstack.app/posts/2019/08/28/cover.png"><meta property="og:description" content="Para implementar o padrão de arquitetura de microsserviços, nós construímos uma coleção de APIs com responsabilidades específicas que trabalham em conjunto e se comunicam através de eventos. Vamos ver como podemos fazer isso."><meta property="og:url" content="https://fullstack.app/br/posts/2019/08/28/arquitetura-de-microsservicos-com-aspnet-core.html"><title>Arquitetura de microsserviços com ASP.NET Core</title><link rel="icon" href="/favicon.ico"><link rel="alternate" href="https://fullstack.app/posts/2019/08/28/microservice-architecture-with-aspnet-core.html" hreflang="en"><link rel="stylesheet" href="https://fonts.googleapis.com/css?family=Source+Serif+Pro:400,700&display=swap"><link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/css/all.min.css" integrity="sha256-UzFD2WYH2U1dQpKDjjZK72VtPeWP50NoJjd26rnAdUI=" crossorigin="anonymous"><link rel="stylesheet" href="/blog.min.css?v=1.2.0"></head><body><div class="container"><div class="text-right mb-3"><div class="dropdown"><button type="button" class="btn btn-sm dropdown-toggle" data-toggle="dropdown">BR</button><div class="dropdown-menu"><a href="/posts/2019/08/28/microservice-architecture-with-aspnet-core.html" class="dropdown-item">EN</a></div></div></div><div class="header"><h1><a href="/br">Full-Stack Applications</a></h1><div class="techs"><svg><use href="/images/techs.svg#netcore"/></svg> <svg><use href="/images/techs.svg#vue"/></svg> <svg><use href="/images/techs.svg#postgresql"/></svg> <svg><use href="/images/techs.svg#rabbitmq"/></svg> <svg><use href="/images/techs.svg#nginx"/></svg> <svg><use href="/images/techs.svg#ubuntu"/></svg> <svg><use href="/images/techs.svg#aws"/></svg> <svg><use href="/images/techs.svg#github"/></svg> <svg><use href="/images/techs.svg#circleci"/></svg></div></div><form method="get" action="https://www.google.com/search" class="google-search"><input type="hidden" name="sitesearch" value="fullstack.app"> <input type="text" name="q" class="form-control form-control-sm" placeholder="Google"></form><small>28 de agosto de 2019</small><h1>Arquitetura de microsserviços com ASP.NET Core</h1><figure><img src="/posts/2019/08/28/cover.svg" alt="Microservices"></figure><p>Para implementar o padrão de arquitetura de microsserviços, nós construímos uma coleção de APIs com responsabilidades específicas que trabalham em conjunto e se comunicam através de eventos. Vamos ver como podemos fazer isso.</p><p>Antes de iniciarmos, é importante saber porque estamos implementando esse padrão. Para saber mais sobre a arquitetura de microsserviços e seus benefícios, você pode ler os artigos de <a href="https://microservices.io">Chris Richardson</a>. Há também um artigo sobre microsserviços na <a href="https://docs.microsoft.com/en-us/azure/architecture/microservices/introduction">documentação da Microsoft</a>.</p><p>Para apresentar e aprender como podemos implemetar a arquitetura de microsserviços, eu trabalharei em uma solução focada no negócio de varejo de alimentos. Essa solução é um projeto de código aberto chamado <a href="https://github.com/storefront-community">Storefront Community</a>.</p><p>O objetivo de negócio é reduzir o tempo de espera e oferecer comodidade para os clientes dos restaurantes. Como solução iremos entregar um totem de autoatendimento (<i>self-order kiosk</i>) onde os clientes podem realizar seus pedidos por conta própria. Tecnicamente, para construir um backend para essa solução adotando a arquitetura de microsserviços, eu vou essencialmente seguir esses três passos:</p><ol><li><a href="#criar-uma-api-gateway">Criar uma API gateway</a></li><li><a href="#configurar-um-event-bus">Configurar um event bus</a></li><li><a href="#construir-apis-baseadas-em-responsabilidade">Construir APIs baseadas em responsabilidade</a></li></ol><p></p><p>Mas para garantir o desenvolvimento do projeto de forma sustentável, os seguintes processos são muito importantes e devem ser considerados:</p><ul><li><b>Testes automatizados</b>: Testes automatizados nos permite testar eficientemente todas as funcionalidades de nossos serviços antes de lançarmos uma nova versão. Isso minimiza consideravelmente a incidência de bugs em novas e antigas funcionalidades (teste de regressão). Publicarei um post sobre como podemos escrever <i>testes automatizados para ASP.NET Core API com xUnit</i>.</li><li><b>CI/CD</b>: Uma ferramenta de integração contínua (CI - <i>continuous integration</i>) e entrega contínua (CD - <i>continuous delivery</i>) executa tarefas automatizadas após alterações realizadas no código fonte e submetidas pela equipe para o versionamento. Essas ferramentas fornecem automação de testes e podem armazenar artefatos (ex. versões compiladas, relatório de testes, etc) e podem também publicar novas versões automaticamente. Escreverei um post sobre como podemos configurar o <i>ASP.NET Core no CircleCI</i>.</li><li><b>Log de erros</b>: É muito importante monitorar nossas aplicações contra falhas. Há bibliotecas e ferramentas de log (SaaS) que podemos usar para capturar, rastrear, gerenciar erros e notificar a equipe automaticamente. Assim, erros serão reportados pela ferramenta e não pelos usuários, com possibilidade de corrigir esses erros antes mesmo deles notarem o problema. Escreverei um post sobre <i>log de erros em ASP.NET Core com Sentry</i>.</li></ul><p></p><h2 id="criar-uma-api-gateway">Criar uma API gateway</h2><p>Uma vez que decidimos implementar o padrão de arquitetura de microsserviços, nós precisaremos de uma API gateway que atuará como um único ponto de entrada responsável por rotear todas as requisições para os outros serviços (outras APIs).</p><p>Para realizar essa tarefa você pode consultar um post que escrevi sobre a implementação de uma <a href="/br/posts/2019/08/20/api-gateway-with-aspnet-core-and-ocelot.html">API gateway com ASP.NET Core e Ocelot</a>. Você também pode encontrar informações sobre esse tema na <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/implement-api-gateways-with-ocelot">documentação da Microsoft</a>.</p><h2 id="configurar-um-event-bus">Configurar um event bus</h2><p>Os serviços destinam-se a desempenhar uma parte específica do negócio e encapsulam sua lógica de implementação e estratégia de persistência. Contudo, eles precisam se comunicar uns com os outros a fim de trabalharem em conjunto para atender às necessidades do negócio.</p><p>A comunicação entre os serviços será realizada por meio de eventos e, para que seja estabelecida, são necessários três agentes:</p><ul><li><b>Event bus</b> (barramento): O canal por onde os eventos serão transmitidos.</li><li><b>Publisher</b>: O serviço que irá emitir os eventos para o <i>event bus</i> quando seus dados forem atualizados.</li><li><b>Subscriber</b>: O serviço que escutará um ou mais eventos através do event bus e será notificado quando esses eventos forem disparados.</li></ul><p></p><p>Publicarei um post sobre como podemos implementar um <i>event bus com RabbitMQ e ASP.NET Core</i>. Também sugiro que você leia o artigo da Microsoft sobre <a href="https://docs.microsoft.com/en-us/dotnet/architecture/microservices/multi-container-microservice-net-applications/integration-event-based-microservice-communications">implementação de comunicação entre microsserviços baseada em eventos (eventos de integração) </a>e artigos relacionados com o RabbitMQ.</p><h2 id="construir-apis-baseadas-em-responsabilidade">Construir APIs baseadas em responsabilidade</h2><p>Nós planejaremos nossos serviços para ter uma única responsabilidade, dessa forma, as equipes poderão focar em desenvolver, manter e publicar cada um de maneira independente.</p><p>Entender e definir uma única responsabilidade para cada serviço é uma tarefa delicada e nós devemos fazer isso de forma planejada. Tenha em mente que nós iremos refatorar e continuamente melhorar nossa estratégia com base nos requisitos do negócio.</p><p>Esse projeto visa atender uma necessidade do negócio de varejo de alimentos. Tecnicamente, eu irei construir um backend para um <a href="https://kiosk.storefront.community">totem de autoatendimento</a> e também para um <a href="https://menu.storefront.community">menu board digital</a>. Esses dois aplicativos nos dão uma boa ideia do que pretendemos alcançar.</p><p>Nos próximos posts eu escreverei sobre a arquitetura de microsserviços planejada e como ela será construída.</p><div class="author"><img src="/images/marxjmoura.jpg" alt="marxjmoura"><div><p class="mb-3">Eu sou Marx J. Moura. Neste blog escrevo sobre arquitetura de microsserviços e desenvolvimento de aplicações web.</p><p><a href="https://github.com/marxjmoura/" class="p-1"><i class="fab fa-lg fa-github"></i> </a><a href="https://www.linkedin.com/in/marxjmoura/" class="p-1"><i class="fab fa-lg fa-linkedin"></i></a></p></div></div><div id="disqus_thread"></div></div><script src="https://cdnjs.cloudflare.com/ajax/libs/font-awesome/5.9.0/js/all.min.js" integrity="sha256-xzrHBImM2jn9oDLORlHS1/0ekn1VyypEkV1ALvUx8lU=" crossorigin="anonymous"></script><script src="/blog.min.js?v=1.2.0"></script><script>var disqus_config = function () {
      this.page.url = 'https://fullstack.app/br/posts/2019/08/28/arquitetura-de-microsservicos-com-aspnet-core.html';
      this.page.identifier = '2019/08/28/microservice-architecture-with-aspnet-core';
    };
    (function() {
      var d = document, s = d.createElement('script');
      s.src = 'https://fullstack-app.disqus.com/embed.js';
      s.setAttribute('data-timestamp', + new Date());
      (d.head || d.body).appendChild(s);
    })();</script></body></html>